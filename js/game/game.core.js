window.game = window.game || {};

window.game.models = {
	player: {
		"metadata" :
		{
			"formatVersion" : 3.1,
			"generatedBy"   : "Blender 2.65 Exporter",
			"vertices"      : 30,
			"faces"         : 29,
			"normals"       : 30,
			"colors"        : 0,
			"uvs"           : [],
			"materials"     : 1,
			"morphTargets"  : 0,
			"bones"         : 0
		},
		"scale" : 1.000000,
		"materials" : [	{
			"DbgColor" : 15658734,
			"DbgIndex" : 0,
			"DbgName" : "default",
			"vertexColors" : false
		}],
		"vertices" : [-0.630989,-0.172923,0.124498,-0.61038,-0.0550892,0.124498,0.477292,0.157815,0.117363,-0.109386,-0.174817,0.343524,0.543707,-0.130769,0.235027,-0.109386,-0.0208133,0.343524,0.543707,0.0115998,0.235027,0.341078,0.176573,0.153652,0.48524,-0.174817,0.197131,0.487585,0.0258092,0.269935,0.487585,-0.174817,0.269935,0.308488,-0.150395,0.642853,0.308488,-0.0184236,0.642853,0.389641,0.00138753,0.623385,0.389641,-0.150395,0.623385,-0.630989,-0.172924,-0.124498,-0.61038,-0.0550892,-0.124498,0.477292,0.157815,-0.117363,-0.109386,-0.174817,-0.343524,0.543707,-0.130769,-0.235027,-0.109386,-0.0208133,-0.343524,0.543707,0.0115997,-0.235027,0.341078,0.176573,-0.153652,0.48524,-0.174817,-0.197131,0.487585,0.0258092,-0.269935,0.487585,-0.174817,-0.269935,0.308488,-0.150395,-0.642853,0.308488,0.00138747,-0.642853,0.389641,-0.0422724,-0.623385,0.389641,-0.150395,-0.623385],
		"morphTargets" : [],
		"normals" : [-0.678915,0.561632,0.472854,-0.707907,-0.555834,0.435743,-0.330271,-0.730125,0.598163,-0.353984,0.541948,0.7622,-0.020661,0.949736,0.312265,0.473403,0.627949,0.617664,0.315287,-0.948973,-0.004761,0.559893,-0.783349,0.269875,0.812189,0.300272,0.500137,0.851222,-0.348552,0.392285,0.567309,0.794427,0.216712,0.520676,0.628712,0.577563,-0.173223,0.566118,0.805872,-0.145421,-0.597949,0.788202,0.553453,-0.5833,0.59447,-0.678915,0.561632,-0.472854,-0.345317,0.541642,-0.76635,-0.330271,-0.730125,-0.598163,-0.707907,-0.555834,-0.435743,-0.020661,0.949736,-0.312265,0.474807,0.631306,-0.613147,0.559893,-0.783349,-0.269875,0.315287,-0.948973,0.004761,0.812189,0.300272,-0.500137,0.851222,-0.348552,-0.392285,0.567309,0.794427,-0.216712,0.560198,0.491195,-0.666982,0.553453,-0.5833,-0.59447,-0.145421,-0.597949,-0.788202,-0.188025,0.649861,-0.736381],
		"colors" : [],
		"uvs" : [],
		"faces" : [35,1,0,3,5,0,0,1,2,3,35,7,1,5,9,0,4,0,3,5,35,0,8,10,3,0,1,6,7,2,35,6,9,10,4,0,8,5,7,9,34,10,8,4,0,7,6,9,35,2,7,9,6,0,10,4,5,8,35,13,12,11,14,0,11,12,13,14,35,9,5,12,13,0,5,3,12,11,35,3,10,14,11,0,2,7,14,13,35,5,3,11,12,0,3,2,13,12,35,10,9,13,14,0,7,5,11,14,35,16,20,18,15,0,15,16,17,18,35,22,24,20,16,0,19,20,16,15,35,15,18,25,23,0,18,17,21,22,35,21,19,25,24,0,23,24,21,20,34,25,19,23,0,21,24,22,35,17,21,24,22,0,25,23,20,19,35,28,29,26,27,0,26,27,28,29,35,24,28,27,20,0,20,26,29,16,35,18,26,29,25,0,17,28,27,21,35,20,27,26,18,0,16,29,28,17,35,25,29,28,24,0,21,27,26,20,35,7,22,16,1,0,4,19,15,0,35,15,0,1,16,0,18,1,0,15,35,0,15,23,8,0,1,18,22,6,35,19,4,8,23,0,24,9,6,22,35,21,6,4,19,0,23,8,9,24,35,22,7,2,17,0,19,4,10,25,35,17,2,6,21,0,25,10,8,23],
		"bones" : [],
		"skinIndices" : [],
		"skinWeights" : [],
		"animation" : {}
	},
	slowMotion: {
		"metadata" :
		{
			"formatVersion" : 3.1,
			"generatedBy"   : "Blender 2.65 Exporter",
			"vertices"      : 40,
			"faces"         : 38,
			"normals"       : 24,
			"colors"        : 0,
			"uvs"           : [],
			"materials"     : 1,
			"morphTargets"  : 0,
			"bones"         : 0
		},
		"scale" : 1.000000,
		"materials" : [	{
			"DbgColor" : 15658734,
			"DbgIndex" : 0,
			"DbgName" : "default",
			"vertexColors" : false
		}],
		"vertices" : [-0.232432,0.446723,0.385838,-0.232432,0.446723,-0.385838,0.232432,0.446723,-0.385838,0.232432,0.446723,0.385838,-0.232432,-0.268034,-0.385838,-0.232432,-0.268034,0.385838,0.232432,-0.268034,-0.385838,0.232432,-0.268034,0.385838,-0.232432,0.0893446,0.385838,-0.232432,0.0893446,-0.385838,0.232432,0.0893446,-0.385838,0.232432,0.0893446,0.385838,-0.232432,0.268034,0.385838,-0.232432,0.268034,-0.385838,0.232432,0.268034,-0.385838,0.232432,0.268034,0.385838,-0.232432,-0.0893446,0.385838,-0.232432,-0.0893446,-0.385838,0.232432,-0.0893446,-0.385838,0.232432,-0.0893446,0.385838,-0.232432,0.446723,0.219061,0.232432,0.446723,0.219061,-0.232432,-0.268034,-0.219061,0.232432,-0.268034,-0.219061,-0.232432,0.0893446,0.219061,0.232432,0.0893446,0.219061,-0.232432,0.268034,0.219061,0.232432,0.268034,0.219061,-0.232432,-0.0893446,-0.219061,0.232432,-0.0893446,-0.219061,-0.232432,-0.446723,-0.385838,0.232432,-0.446723,-0.385838,0.232432,-0.446723,0.385838,-0.232432,-0.446723,0.385838,-0.232432,-0.446723,-0.219061,0.232432,-0.446723,-0.219061,0.232432,0.0893446,-0.219061,-0.232432,0.0893446,-0.219061,0.232432,-0.0893446,0.219061,-0.232432,-0.0893446,0.219061],
		"morphTargets" : [],
		"normals" : [0.707083,0.707083,0,0.577349,0.577349,-0.577349,-0.577349,0.577349,-0.577349,-0.707083,0.707083,0,-0.904508,-0.301492,0.301492,-0.707083,0,-0.707083,-0.904508,0.301492,0.301492,0.707083,0,-0.707083,0.904508,-0.301492,-0.301492,0.707083,0,0.707083,0.904508,0.301492,-0.301492,-0.707083,0,0.707083,-0.577349,-0.577349,-0.577349,-0.904508,-0.301492,-0.301492,0.577349,0.577349,0.577349,-0.577349,0.577349,0.577349,0.577349,-0.577349,0.577349,0.707083,-0.707083,0,0.904508,-0.301492,0.301492,0.904508,0.301492,0.301492,-0.904508,0.301492,-0.301492,0.577349,-0.577349,-0.577349,-0.707083,-0.707083,0,-0.577349,-0.577349,0.577349],
		"colors" : [],
		"uvs" : [],
		"faces" : [35,21,2,1,20,0,0,1,2,3,35,28,17,4,22,0,4,5,5,6,35,17,18,6,4,0,5,7,7,5,35,27,15,11,25,0,8,9,9,10,35,15,12,8,11,0,9,11,11,9,35,20,1,13,26,0,3,2,12,13,35,21,3,15,27,0,0,14,9,8,35,3,0,12,15,0,14,15,11,9,35,19,38,25,11,0,16,17,10,9,35,36,25,38,29,0,0,10,17,18,35,20,0,3,21,0,3,15,14,0,35,18,29,23,6,0,7,18,19,7,35,12,26,24,8,0,11,13,20,11,35,0,20,26,12,0,15,3,13,11,35,2,21,27,14,0,1,0,8,21,35,36,29,18,10,0,0,18,7,1,35,29,28,22,23,0,18,4,6,19,35,22,4,30,34,0,6,5,12,22,35,4,6,31,30,0,5,7,21,12,35,23,7,32,35,0,19,14,16,17,35,5,22,34,33,0,15,6,22,23,35,6,23,35,31,0,7,19,17,21,35,32,33,34,35,0,16,23,22,17,35,30,31,35,34,0,12,21,17,22,35,27,26,13,14,0,8,13,12,21,35,36,37,24,25,0,0,3,20,10,35,13,1,2,14,0,12,2,1,21,35,26,27,25,24,0,13,8,10,20,35,38,39,28,29,0,17,22,4,18,35,39,38,19,16,0,22,17,16,23,35,8,16,19,11,0,11,23,16,9,35,23,22,5,7,0,19,6,15,14,35,33,32,7,5,0,23,16,14,15,35,18,17,9,10,0,7,5,2,1,35,37,36,10,9,0,3,0,1,2,35,24,39,16,8,0,20,22,23,11,35,24,37,28,39,0,20,3,4,22,35,17,28,37,9,0,5,4,3,2],
		"bones" : [],
		"skinIndices" : [],
		"skinWeights" : [],
		"animation" : {}
	},
	movingPlatform: {
		"metadata" :
		{
			"formatVersion" : 3.1,
			"generatedBy"   : "Blender 2.65 Exporter",
			"vertices"      : 12,
			"faces"         : 10,
			"normals"       : 12,
			"colors"        : 0,
			"uvs"           : [],
			"materials"     : 1,
			"morphTargets"  : 0,
			"bones"         : 0
		},
		"scale" : 1.000000,
		"materials" : [	{
			"DbgColor" : 15658734,
			"DbgIndex" : 0,
			"DbgName" : "default",
			"vertexColors" : false
		}],
		"vertices" : [-0.4,-0.0834488,0.362053,-0.4,-0.0834488,-0.362053,0.4,-0.0834488,-0.362053,0.4,-0.0834488,0.362053,-0.4,0.0834488,0.362053,-0.4,0.0834488,-0.362053,0.4,0.0834488,-0.362053,0.4,0.0834488,0.362053,0,0.0834487,-0.522763,0,-0.0834488,-0.522763,0,0.0834488,0.522763,0,-0.0834487,0.522763],
		"morphTargets" : [],
		"normals" : [-0.662679,-0.600116,-0.44792,-0.662679,-0.600116,0.44792,-0.662679,0.600116,0.44792,-0.662679,0.600116,-0.44792,0,0.632008,-0.774926,0.662679,0.600116,-0.44792,0.662679,-0.600116,-0.44792,0,-0.632008,-0.774926,0.662679,0.600116,0.44792,0.662679,-0.600116,0.44792,0,-0.632008,0.774926,0,0.632008,0.774926],
		"colors" : [],
		"uvs" : [],
		"faces" : [35,1,0,4,5,0,0,1,2,3,35,8,6,2,9,0,4,5,6,7,35,6,7,3,2,0,5,8,9,6,35,0,11,10,4,0,1,10,11,2,35,11,9,2,3,0,10,7,6,9,35,10,8,5,4,0,11,4,3,2,35,5,8,9,1,0,3,4,7,0,35,7,10,11,3,0,8,11,10,9,35,0,1,9,11,0,1,0,7,10,35,7,6,8,10,0,8,5,4,11],
		"bones" : [],
		"skinIndices" : [],
		"skinWeights" : [],
		"animation" : {}
	}
};

window.game.core = function () {
	var _game = {
		// Attributes
		player: {
			// Attributes
			model: null,
			modelSlowMotion: null,
			modelMovingPlatform: null,
			mesh: null,
			shape: null,
			physicsMaterial: null,
			rigidBody: null,
			orientationConstraint: null,
			mass: 3,
			hasPlatformCollision: false,
			isGrounded: false,
			isBouncing: false,
			isAirboosting: false,
			isSlowMotion: false,
			jumpHeight: 45,
			speed: 2,
			speedDefault: 2,
			speedMax: 65,
			speedMaxDefault: 65,
			speedSlowMotion: 5,
			speedMaxSlowMotion: 70,
			rotationSpeedDefault: 0.007,
			rotationSpeed: 0.007,
			rotationSpeedMaxDefault: 0.040,
			rotationSpeedMax: 0.040,
			rotationSpeedSlowMotion: 0.002,
			rotationSpeedMaxSlowMotion: 0.03,
			rotationRadians: new THREE.Vector3(0, 0, 0),
			rotationAngleX: null,
			rotationAngleY: null,
			damping: 0.9,
			rotationDamping: 0.8,
			acceleration: 0,
			rotationAcceleration: 0,
			playerCoords: null,
			cameraCoords: null,
			cameraOffsetH: 340,
			cameraOffsetV: 200,
			playerLightOffset: 60,
			trailGeometry: null,
			trailSize: 800,
			trailOffset: null,
			trailMaterial: null,
			groundDestinationPlaneMesh: null,
			playerToPlatformDistance: null,
			playerAccelerationValues: {
				position: {
					acceleration: "acceleration",
					speed: "speed",
					speedMax: "speedMax",
					speedMaxDefault: "speedMaxDefault"
				},
				rotation: {
					acceleration: "rotationAcceleration",
					speed: "rotationSpeed",
					speedMax: "rotationSpeedMax",
					speedMaxDefault: "rotationSpeedMaxDefault"
				}
			},
			controlKeys: {
				forward: "w",
				backward: "s",
				left: "a",
				right: "d",
				inAirBoost: "e"
			},
			// Methods
			create: function() {
				_game.player.physicsMaterial = _cannon.playerPhysicsMaterial = new CANNON.Material("playerMaterial");

				_game.player.model = _three.createModel(window.game.models.player, 12, new THREE.MeshLambertMaterial({ color: window.game.static.colors.darkerMidGreen, shading: THREE.FlatShading, fog: false }));
				_game.player.modelSlowMotion = _three.createModel(window.game.models.slowMotion, 30, new THREE.MeshLambertMaterial({ color: window.game.static.colors.darkerMidGreen, shading: THREE.FlatShading }));
				_game.player.modelMovingPlatform = _three.createModel(window.game.models.movingPlatform, 80, new THREE.MeshLambertMaterial({ color: window.game.static.colors.darkerMidGreen, shading: THREE.FlatShading }));

				_game.player.shape = new CANNON.Box(_game.player.model.halfExtents);
				_game.player.rigidBody = new CANNON.RigidBody(_game.player.mass, _game.player.shape, _cannon.createPhysicsMaterial(_game.player.physicsMaterial));
				_game.player.rigidBody.position.set(0, 0, 50);
				_game.player.mesh = _cannon.addVisual(_game.player.rigidBody, null, _game.player.model.mesh);

				_game.player.orientationConstraint = new CANNON.HingeConstraint(_game.player.rigidBody, new CANNON.Vec3(0, 0, 0), new CANNON.Vec3(0, 0, 1), _game.player.rigidBody, new CANNON.Vec3(0, 0, 1), new CANNON.Vec3(0, 0, 1));
				_cannon.world.addConstraint(_game.player.orientationConstraint);

				_game.player.rigidBody.postStep = function() {
					_game.player.rigidBody.angularVelocity.z = 0;
					_game.player.updateOrientation();
				};

				_game.player.rigidBody.addEventListener("collide", function(event) {
					// Update airboosts
					if (!_game.player.hasPlatformCollision || (event.contact.bi.gameFlags.booster && !_game.player.isBouncing)) {
						if (_game.level.airboostCollisions.indexOf(event.contact.bi.id) !== -1) {
							_game.level.airboostProgress = 0;
							_ui.setElementAttribute("airboostsProgress", "data-count", _game.level.airboostProgress);
						} else {
							_game.level.airboostCollisions.push(event.contact.bi.id);

							if (_game.level.airboostCollisions.length > 1) {
								_game.level.airboostProgress++;

								if (_game.level.airboostProgress >= 10) {
									_game.level.airboostProgress = 0;
									_game.level.airboostCount++;

									_ui.setElementValue("airboosts", _game.level.airboostCount);
								} else {
									window.clearInterval(_game.level.airboostFlickerInterval);
									window.clearTimeout(_game.level.airboostResetProgressTimeout);

									_game.level.airboostFlickerInterval = window.setInterval(function () {
										if (!_ui.getElementAttribute("airboostsProgress", "data-visible") || _ui.getElementAttribute("airboostsProgress", "data-visible") === "false") {
											_ui.setElementAttribute("airboostsProgress", "data-visible", "true");
											_ui.toggleElement("airboostsProgress", true);
										} else {
											_ui.setElementAttribute("airboostsProgress", "data-visible", "false");
											_ui.toggleElement("airboostsProgress", false);
										}
									}, 200);

									_game.level.airboostResetProgressTimeout = window.setTimeout(function () {
										_game.level.airboostProgress = 0;

										_ui.setElementAttribute("airboostsProgress", "data-count", _game.level.airboostProgress);
										_ui.updateAirboostUi();
									}, _game.level.airboostResetProgressAfterTime);
								}

								_ui.setElementAttribute("airboostsProgress", "data-count", _game.level.airboostProgress);
							}
						}
					}

					// Sound
					if (!_game.player.hasPlatformCollision) {
						_game.audio.platform.pause();
						_game.audio.platform.currentTime = 0;
						_game.audio.platform.play();
					}

					_game.player.hasPlatformCollision = true;

					// Checks if player's is on ground
					if (!_game.player.isGrounded || _cannon.getCollisions(_game.player.rigidBody.index) == 1) {
						_game.player.isGrounded = (new CANNON.Ray(_game.player.mesh.position, new CANNON.Vec3(0, 0, -1)).intersectBody(event.contact.bi).length > 0);
					}

					if (event.contact.bi.gameFlags.bounce) {
						_game.player.rigidBody.velocity.set(_game.player.playerCoords.x, _game.player.playerCoords.y, event.contact.bi.gameFlags.bounce);
						_game.player.isBouncing = true;

						_ui.updateAirboostUi();

						setTimeout(function () {
							_game.player.isBouncing = false;
							_game.player.hasPlatformCollision = false;
						}, 500);
					}

					if (event.contact.bi.gameFlags.slowMotionItem) {
						_game.level.toggleSlowMotion();
						_game.player.isSlowMotion = true;

						_game.audio.slowmotion.pause();
						_game.audio.slowmotion.currentTime = 0;
						_game.audio.slowmotion.play();
					}

					if ((event.contact.bi.gameFlags.bounce && event.contact.bi.gameFlags.booster) || event.contact.bi.gameFlags.collectible) {
						setTimeout(function () {
							if (event.contact.bi.gameFlags.booster || event.contact.bi.gameFlags.collectible) {
								_cannon.removeVisual(event.contact.bi);
							}
						}, 100);
					}

					_game.level.platforms.lastLandingPlatform = event.contact.bi;
				});

				_game.player.trail.create();
				_game.player.groundDestinationPlane.create();
			},
			trail: {
				create: function() {
					var trailLine;

					_game.player.trailGeometry = new THREE.Geometry();
					_game.player.trailMaterial = new THREE.LineBasicMaterial({
						color: window.game.static.colors.brightGreen
					});

					for (var i = 0; i < _game.player.trailSize; i++) {
						_game.player.trailGeometry.vertices.push(new THREE.Vector3(0, 0, 50));
					}

					trailLine = new THREE.Line(_game.player.trailGeometry, _game.player.trailMaterial);

					_three.scene.add(trailLine);
				},
				update: function() {
					_game.trailOffset = window.game.helpers.polarToCartesian(0, _game.player.rotationRadians.z);

					_game.player.trailGeometry.vertices[_game.player.trailSize - 1] = new THREE.Vector3(
							_game.player.mesh.position.x + _game.trailOffset.x,
							_game.player.mesh.position.y - _game.trailOffset.y,
						_game.player.mesh.position.z
					);

					for (var i = 0; i < _game.player.trailSize - 1; i++) {
						_game.player.trailGeometry.vertices[i] = _game.player.trailGeometry.vertices[i + 1];
					}

					_game.player.trailGeometry.verticesNeedUpdate = true;
				}
			},
			groundDestinationPlane: {
				create: function () {
					_game.player.groundDestinationPlaneMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ color: window.game.static.colors.darkGreen, side: THREE.DoubleSide, fog: false }));
					_three.scene.add(_game.player.groundDestinationPlaneMesh);
				},
				update: function () {
					var isIntersecting = false;
					var intersectionDistance = 0;

					_game.player.groundDestinationPlaneMesh.visible = true;

					_cannon.bodies.forEach(function (body) {
						var intersections = new CANNON.Ray(_game.player.mesh.position, new CANNON.Vec3(0, 0, -1)).intersectBody(body);

						if (intersections.length > 0 && intersections[0].body.visualref.uuid !== _game.player.rigidBody.visualref.uuid) {
							isIntersecting = true;
							intersectionDistance = intersections[0].distance;

							_game.player.groundDestinationPlaneMesh.position.x = intersections[0].point.x;
							_game.player.groundDestinationPlaneMesh.position.y = intersections[0].point.y;
							_game.player.groundDestinationPlaneMesh.position.z = intersections[0].point.z + 2;
						}
					});

					if (!isIntersecting || (isIntersecting && intersectionDistance < 20)) {
						_game.player.groundDestinationPlaneMesh.visible = false;
					}
				}
			},
			checkGameOver: function () {
				if (_game.level.platforms.lastLandingPlatform) {
					_game.player.playerToPlatformDistance = (_game.player.mesh.position.z - (_game.level.platforms.lastLandingPlatform.position.z + _game.level.platforms.lastLandingPlatform.shape.halfExtents.z));

					if (_game.player.playerToPlatformDistance < _game.level.maxPlayerToLastPlatformDistance) {
						_game.destroy();
					}
				}
			},
			update: function() {
				_game.player.processUserInput();
				_game.player.accelerate();
				_game.player.rotate();
				_game.player.updateCamera();
				_game.player.updatePlayerLight();
				_game.player.trail.update();
				_game.player.groundDestinationPlane.update();
				_game.player.checkGameOver();

				_game.level.gridGround.update();

				_ui.updateUi();
			},
			updateCamera: function() {
				// Calculate camera coordinates by using Euler radians from player's last rotation
				_game.player.cameraCoords = window.game.helpers.polarToCartesian(_game.player.cameraOffsetH, _game.player.rotationRadians.z);

				// Apply camera coordinates to camera position
				_three.camera.position.x = _game.player.mesh.position.x + _game.player.cameraCoords.x;
				_three.camera.position.y = _game.player.mesh.position.y + _game.player.cameraCoords.y;
				_three.camera.position.z = _game.player.mesh.position.z + _game.player.cameraOffsetV;

				// Place camera focus on player mesh
				_three.camera.lookAt(_game.player.mesh.position);
			},
			updatePlayerLight: function() {
				_three.playerLight.position.set(_game.player.mesh.position.x, _game.player.mesh.position.y, _game.player.mesh.position.z + _game.player.playerLightOffset);
			},
			updateAcceleration: function(values, direction) {
				if (direction === 1) {
					if (_game.player[values.acceleration] > -_game.player[values.speedMax]) {
						if (_game.player[values.acceleration] >= _game.player[values.speedMaxDefault] / 2) {
							_game.player[values.acceleration] = -(_game.player[values.speedMax] / 4);
						} else {
							_game.player[values.acceleration] -= _game.player[values.speed];
						}
					} else {
						_game.player[values.acceleration] = -_game.player[values.speedMax];
					}
				} else {
					if (_game.player[values.acceleration] < _game.player[values.speedMax]) {
						if (_game.player[values.acceleration] <= -(_game.player[values.speedMaxDefault] / 2)) {
							_game.player[values.acceleration] = _game.player[values.speedMax] / 4;
						} else {
							_game.player[values.acceleration] += _game.player[values.speed];
						}
					} else {
						_game.player[values.acceleration] = _game.player[values.speedMax];
					}
				}
			},
			processUserInput: function() {
				// Jump
				if (_events.keyboard.pressed["space"]) {
					_game.player.jump();
				}

				// Movement: forward, backward, left, right
				if (_events.keyboard.pressed[_game.player.controlKeys.forward]) {
					_game.player.updateAcceleration(_game.player.playerAccelerationValues.position, 1);

					// Reset orientation in air
					if (!_cannon.getCollisions(_game.player.rigidBody.index)) {
						_game.player.rigidBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), _game.player.rotationRadians.z);
					}
				}

				if (_events.keyboard.pressed[_game.player.controlKeys.backward]) {
					_game.player.updateAcceleration(_game.player.playerAccelerationValues.position, -1);
				}

				if (_events.keyboard.pressed[_game.player.controlKeys.right]) {
					_game.player.updateAcceleration(_game.player.playerAccelerationValues.rotation, 1);
				}

				if (_events.keyboard.pressed[_game.player.controlKeys.left]) {
					_game.player.updateAcceleration(_game.player.playerAccelerationValues.rotation, -1);
				}

				// Add new blocks to level
				if (_events.keyboard.pressed[_game.player.controlKeys.forward] || _events.keyboard.pressed[_game.player.controlKeys.backward]) {
					_game.level.checkForNewBlocks();
				}
			},
			accelerate: function() {
				// Calculate player coordinates by using current acceleration Euler radians from player's last rotation
				_game.player.playerCoords = window.game.helpers.polarToCartesian(_game.player.acceleration, _game.player.rotationRadians.z);

				// Set actual XYZ velocity by using calculated cartesian coordinates
				_game.player.rigidBody.velocity.set(_game.player.playerCoords.x, _game.player.playerCoords.y, _game.player.rigidBody.velocity.z);

				// Damping
				if (!_events.keyboard.pressed[_game.player.controlKeys.forward] && !_events.keyboard.pressed[_game.player.controlKeys.backward]) {
					_game.player.acceleration *= _game.player.damping;
				}
			},
			rotate: function() {
				// Rotate player around Z axis
				_cannon.rotateOnAxis(_game.player.rigidBody, new CANNON.Vec3(0, 0, 1), _game.player.rotationAcceleration);

				// Damping
				if (!_events.keyboard.pressed[_game.player.controlKeys.left] && !_events.keyboard.pressed[_game.player.controlKeys.right]) {
					_game.player.rotationAcceleration *= _game.player.rotationDamping;
				}
			},
			jump: function() {
				if (_cannon.getCollisions(_game.player.rigidBody.index) && _game.player.isGrounded && !_game.player.isBouncing) {
					_game.player.isGrounded = false;
					_game.player.rigidBody.velocity.z = _game.player.jumpHeight;

					_ui.updateAirboostUi();

					setTimeout(function() {
						_game.player.hasPlatformCollision = false;
					}, 500);
				}
			},
			airboost: function() {
				if (!_game.player.isAirboosting && _game.level.airboostCount > 0) {
					_game.player.isAirboosting = true;
					_game.level.airboostCount--;
					_ui.setElementValue("airboosts", _game.level.airboostCount);

					if (_game.level.airboostCount < 0) {
						_game.level.airboostCount = 0;
					}

					_cannon.world.gravity.set(0, 0, 40);

					setTimeout(function() {
						_cannon.world.gravity.set(0, 0, _cannon.gravity);
					}, 300);

					setTimeout(function() {
						_game.player.isAirboosting = false;
					}, 1500);
				}
			},
			updateOrientation: function() {
				// Convert player's Quaternion to Euler radians and save in _game.player.rotationRadians
				_game.player.rotationRadians = new THREE.Euler().setFromQuaternion(_game.player.rigidBody.quaternion);

				// Round angles
				_game.player.rotationAngleX = Math.round(window.game.helpers.radToDeg(_game.player.rotationRadians.x));
				_game.player.rotationAngleY = Math.round(window.game.helpers.radToDeg(_game.player.rotationRadians.y));

				if ((_cannon.getCollisions(_game.player.rigidBody.index) &&
					((_game.player.rotationAngleX >= 90) ||
						(_game.player.rotationAngleX <= -90) ||
						(_game.player.rotationAngleY >= 90) ||
						(_game.player.rotationAngleY <= -90)))
					)
				{
					// Reset orientation
					_game.player.rigidBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), _game.player.rotationRadians.z);
				}
			}
		},
		level: {
			// Attributes
			score: 0,
			reached: 1,
			lastLevelReached: false,
			isIncreasedFog: false,
			level2Checkpoint: 6000,
			level3Checkpoint: 12000,
			level4Checkpoint: 18000,
			level4DarknessCheckpoint: 20000,
			maxPlayerToLastPlatformDistance: -1400,
			fogIncreaseTimeout: -1,
			slowMotionTimeout: -2,
			slowMotionFlickerInterval: -3,
			slowMotionFlickerActivationTimeout: -4,
			airboostFlickerInterval: -5,
			airboostResetProgressTimeout: -6,
			slowMotionTime: 10000,
			slowMotionFlickerAfterTime: 7000,
			airboostResetProgressAfterTime: 1000,
			airboostCount: 0,
			airboostProgress: 0,
			airboostCollisions: [],
			gridGround: {
				// Attributes
				gridGroundPlane: null,
				// Methods
				create: function () {
					_game.level.gridGroundPlane = window.game.helpers.createGradientGrid(4000, 400, window.game.static.colors.midGreenBlue, window.game.static.colors.darkGreen);
					_game.level.gridGroundPlane.rotation.x = Math.PI / 2;

					_three.scene.add(_game.level.gridGroundPlane);
				},
				update: function () {
					_game.level.gridGroundPlane.position.x = _game.player.mesh.position.x - 4000;
					_game.level.gridGroundPlane.position.y = _game.player.mesh.position.y;
					_game.level.gridGroundPlane.position.z = _game.player.mesh.position.z - 1200;
				}
			},
			platforms: {
				lastPlatformPosition: {
					x: 0,
					y: 0,
					z: 0
				},
				lastPlatformSize: {
					x: 0,
					y: 0,
					z: 0
				},
				count: 0,
				maxCount: 50,
				minSize: 50,
				maxSize: 75,
				maxPlatformToPlayerDistance: 75,
				minVariationHorizontal: 170,
				maxVariationHorizontal: 210,
				minPlayerDistance: -1600,
				newPlatformSize: null,
				newPlatformPosition: null,
				currentGroupId: null,
				currentGroupTempId: null,
				lastLandingPlatform: null,
				groups: [],
				references: [],
				x: [],
				y: [],
				z: []
			},

			// Methods
			create: function() {
				_cannon.solidMaterial = _cannon.createPhysicsMaterial(new CANNON.Material("solidMaterial"), 0, 0.1);
				_cannon.bounceMaterial = _cannon.createPhysicsMaterial(new CANNON.Material("bounceMaterial"), 0, 2);

				_game.level.gridGround.create();

				// Starter block
				_game.level.addPlatform({
					size: [150, 150, 5000],
					position: [0, 0, -5000],
					exclude: true
				});

				_game.level.checkForNewBlocks();

				_ui.setElementValue("height", _game.level.score);
				_ui.setElementValue("airboosts", _game.level.airboostCount);
				_ui.setElementAttribute("airboostsProgress", "data-count", _game.level.airboostProgress);
			},
			addPlatform: function(options) {
				var boxShape = new CANNON.Box(new CANNON.Vec3(options.size[0], options.size[1], options.size[2]));

				var boxRigidBody = _cannon.createRigidBody({
					shape: boxShape,
					mass: options.mass || 0,
					position: new CANNON.Vec3(options.position[0], options.position[1], options.position[2]),
					rotation: options.rotation || null,
					meshMaterial: options.meshMaterial || new THREE.MeshLambertMaterial({ wireframe: options.wireframe || false, color: options.color ? options.color : (options.booster ? window.game.static.colors.midGreen : (options.bounce ? window.game.static.colors.yellow : window.game.static.colors.midBlue)), visible: false }),
					physicsMaterial: options.physicsMaterial || _cannon.solidMaterial,
					customMesh: options.customMesh,
					gameFlags: {
						autoRotation: options.autoRotation || null,
						bounce: options.bounce,
						booster: options.booster,
						collectible: options.collectible,
						slowMotionItem: options.slowMotionItem
					}
				});

				// Store platform group id in RigidBody object
				boxRigidBody.platformGroupId = options.groupId || _game.level.platforms.count;

				boxRigidBody.visualref.material.visible = false;

				if (options.exclude) {
					// Add platform to references/groups
					_game.level.platforms.count++;
					_game.level.platforms.references.push(boxRigidBody);
					_game.level.platforms.groups.push(boxRigidBody.platformGroupId);

					if (options.delayVisibility) {
						setTimeout(function() {
							boxRigidBody.visualref.material.visible = true;
						}, 10);
					} else {
						boxRigidBody.visualref.material.visible = true;
					}
				} else {
					_game.level.platforms.lastPlatformPosition = {
						x: options.position[0],
						y: options.position[1],
						z: options.position[2]
					};

					_game.level.platforms.lastPlatformSize = {
						x: options.size[0],
						y: options.size[1],
						z: options.size[2]
					};

					// Moving platforms
					if (options.moving) {
						boxRigidBody.gameFlags.initPositionY = boxRigidBody.position.y + 60;
						boxRigidBody.gameFlags.targetPositionY = boxRigidBody.position.y - 60;
						boxRigidBody.gameFlags.targetPositionReached = false;

						boxRigidBody.postStep = function () {
							if (boxRigidBody.position.y > boxRigidBody.gameFlags.targetPositionY && !boxRigidBody.gameFlags.targetPositionReached) {
								boxRigidBody.position.y -= 0.7;
							} else {
								boxRigidBody.gameFlags.targetPositionReached = true;
								boxRigidBody.position.y += 0.7;

								if (boxRigidBody.position.y >= boxRigidBody.gameFlags.initPositionY) {
									boxRigidBody.gameFlags.targetPositionReached = false;
								}
							}
						};
					}

					// Save last block coordinates
					_game.level.platforms.x.push(options.position[0] - (options.size[0] / 2));

					// Add platform to references/groups
					_game.level.platforms.count++;
					_game.level.platforms.references.push(boxRigidBody);
					_game.level.platforms.groups.push(boxRigidBody.platformGroupId);

					setTimeout(function() {
						boxRigidBody.visualref.material.visible = true;
					}, 10);
				}
			},
			addLevelPlatforms: function (count) {
				var boosterSize;
				var platformAdditionalSpaceX;
				var platformAdditionalSpaceNegativeX;
				var boosterStrength;
				var bounceStrength;

				if (_game.level.reached === 1) {
					// Level 1
					_game.level.newPlatformSize = [_game.level.platforms.maxSize, _game.level.platforms.maxSize, _game.level.platforms.maxSize];
					platformAdditionalSpaceX = _game.level.newPlatformSize[0] * 1.1;
					platformAdditionalSpaceNegativeX = -platformAdditionalSpaceX;
					boosterStrength = 80;
					bounceStrength = 110;
					_game.level.newPlatformSize[2] /= 6;
				} else if (_game.level.reached === 2) {
					// Level 2
					_game.level.maxPlatformToPlayerDistance = 400;
					_game.level.minVariationHorizontal = 210;
					_game.level.maxVariationHorizontal = 260;

					_game.level.newPlatformSize = [_game.level.platforms.minSize, _game.level.platforms.minSize, _game.level.platforms.minSize];
					platformAdditionalSpaceX = _game.level.newPlatformSize[0] * 5;
					platformAdditionalSpaceNegativeX = _game.level.newPlatformSize[0] * 0.8;
					boosterStrength = 75;
					bounceStrength = 80;
					_game.level.newPlatformSize[2] /= 4;
				} else {
					// Level 3 + 4
					_game.level.maxPlatformToPlayerDistance = 80;
					_game.level.minVariationHorizontal = 200;
					_game.level.maxVariationHorizontal = 240;

					_game.level.newPlatformSize = [_game.level.platforms.minSize / 1.8, _game.level.platforms.minSize / 1.8, _game.level.platforms.minSize / 1.8];
					platformAdditionalSpaceX = _game.level.lastLevelReached ? 0 : _game.level.newPlatformSize[0] * 14;
					platformAdditionalSpaceNegativeX = _game.level.newPlatformSize[0] * 0.5;
					bounceStrength = 62;
					_game.level.newPlatformSize[2] = 6.7;
				}

				boosterSize = _game.level.newPlatformSize[0] / 3.5;

				if (_game.level.reached === 4) {
					_game.level.addPlatform({
						size: [_game.player.modelMovingPlatform.halfExtents.x, _game.player.modelMovingPlatform.halfExtents.y, _game.player.modelMovingPlatform.halfExtents.z],
						position: _game.level.getLastPlatformPosition(
							-(_game.level.getMaxPlatformToPlayerDistance(0, platformAdditionalSpaceX)),
							_game.level.getHorizontalVariation(),
								_game.level.newPlatformSize[0] * window.game.helpers.random(0.4, 0.6)
						),
						customMesh: _three.createModel(window.game.models.movingPlatform, 80, new THREE.MeshLambertMaterial({ color: window.game.static.colors.darkerMidGreen, shading: THREE.FlatShading })).mesh,
						bounce: bounceStrength,
						color: window.game.static.colors.midGreen,
						collectible: true,
						moving: true
					});
				} else {
					_game.level.addPlatform({
						size: _game.level.newPlatformSize,
						position: _game.level.getLastPlatformPosition(
							-(_game.level.getMaxPlatformToPlayerDistance(0, platformAdditionalSpaceX)),
							_game.level.getHorizontalVariation(),
								_game.level.newPlatformSize[0] * window.game.helpers.random(0.4, 0.6)
						),
						bounce: _game.level.reached === 3 ? bounceStrength : null,
						color: _game.level.reached === 3 ? window.game.static.colors.midGreen : null,
						collectible: _game.level.reached === 3
					});
				}

				// Booster
				if (_game.level.reached < 3) {
					_game.level.addPlatform({
						size: [boosterSize, boosterSize, (boosterSize / 7)],
						position: _game.level.getLastPlatformPosition(
								-_game.level.getLastPlatformSize()[0] + boosterSize,
								-_game.level.getLastPlatformSize()[1] + boosterSize,
								_game.level.getLastPlatformSize()[2] + (boosterSize / 7)
						),
						bounce: boosterStrength,
						booster: true,
						exclude: true,
						delayVisibility: true
					});
				}

				for (var i = 0; i < (count - 1); i++) {
					var isBouncer = window.game.helpers.random(0, 15, true) === 5;
					var isSlowMotion = window.game.helpers.random(0, 15, true) === 5;

					if (_game.level.reached === 4) {
						_game.level.addPlatform({
							size: [_game.player.modelMovingPlatform.halfExtents.x, _game.player.modelMovingPlatform.halfExtents.y, _game.player.modelMovingPlatform.halfExtents.z],
							position: _game.level.getLastPlatformPosition(
								-_game.level.getMaxPlatformToPlayerDistance(0, (window.game.helpers.random(0, 5, true) === 1 ? platformAdditionalSpaceX : platformAdditionalSpaceNegativeX)),
								_game.level.getHorizontalVariation(),
									_game.level.newPlatformSize[0] * window.game.helpers.random(0.4, 0.6)
							),
							customMesh: _three.createModel(window.game.models.movingPlatform, 80, new THREE.MeshLambertMaterial({ color: window.game.static.colors.darkerMidGreen, shading: THREE.FlatShading })).mesh,
							bounce: bounceStrength,
							color: window.game.static.colors.midGreen,
							collectible: true,
							moving: true
						});
					} else {
						_game.level.addPlatform({
							size: _game.level.newPlatformSize,
							position: _game.level.getLastPlatformPosition(
								-_game.level.getMaxPlatformToPlayerDistance(0, (window.game.helpers.random(0, 5, true) === 1 ? platformAdditionalSpaceX : platformAdditionalSpaceNegativeX)),
								_game.level.getHorizontalVariation(),
									_game.level.newPlatformSize[0] * window.game.helpers.random(0.4, 0.6)
							),
							bounce: _game.level.reached === 3 || isBouncer ? bounceStrength : null,
							color: _game.level.reached === 3 ? window.game.static.colors.midGreen : null,
							collectible: _game.level.reached === 3
						});
					}

					// Booster
					if (_game.level.reached < 3) {
						if (!isBouncer) {
							_game.level.addPlatform({
								size: [boosterSize, boosterSize, (boosterSize / 7)],
								position: _game.level.getLastPlatformPosition(
										-_game.level.getLastPlatformSize()[0] + boosterSize,
										-_game.level.getLastPlatformSize()[1] + boosterSize,
										_game.level.getLastPlatformSize()[2] + (boosterSize / 7)
								),
								bounce: boosterStrength,
								booster: true,
								exclude: true,
								delayVisibility: true
							});

							// SlowMotion
							if (isSlowMotion) {
								_game.level.addPlatform({
									size: [_game.player.modelSlowMotion.halfExtents.x, _game.player.modelSlowMotion.halfExtents.y, _game.player.modelSlowMotion.halfExtents.z],
									position: _game.level.getLastPlatformPosition(
										0,
										0,
											_game.level.getLastPlatformSize()[2] + _game.player.modelSlowMotion.halfExtents.z
									),
									customMesh: _three.createModel(window.game.models.slowMotion, 30, new THREE.MeshLambertMaterial({ color: window.game.static.colors.darkerMidGreen, shading: THREE.FlatShading })).mesh,
									exclude: true,
									delayVisibility: true,
									collectible: true,
									autoRotation: true,
									slowMotionItem: true
								});
							}
						}
					}
				}
			},
			addBlock: function(lastPlatformPosition) {
				var removedPlatformPositionX;

				_game.level.lastLevelReached = _game.level.reached === 2 && lastPlatformPosition[2] >= _game.level.level3Checkpoint;

				// Levels
				if (lastPlatformPosition[2] >= _game.level.level2Checkpoint && lastPlatformPosition[2] < _game.level.level3Checkpoint) {
					_game.level.reached = 2;
				} else if (lastPlatformPosition[2] >= _game.level.level3Checkpoint && lastPlatformPosition[2] < _game.level.level4Checkpoint) {
					_game.level.reached = 3;
				} else if (lastPlatformPosition[2] >= _game.level.level4Checkpoint && lastPlatformPosition[2] < _game.level.level4DarknessCheckpoint) {
					_game.level.reached = 4;
				} else if (lastPlatformPosition[2] >= _game.level.level4DarknessCheckpoint) {
					_game.level.increaseFogDepth();
				}

				// Add 3 platform objects depending on current level
				_game.level.addLevelPlatforms(3);

				// Limit max platforms
				if (_game.level.platforms.references.length > _game.level.platforms.maxCount) {
					_game.level.platforms.currentGroupTempId = _game.level.platforms.references[0].platformGroupId;

					do {
						_cannon.removeVisual(_game.level.platforms.references[0]);
						_game.level.platforms.references.shift();
						_game.level.platforms.groups.shift();

						removedPlatformPositionX = _game.level.platforms.x.indexOf((_game.level.platforms.references[0].position.x - _game.level.platforms.references[0].shape.halfExtents.x / 2));

						if (removedPlatformPositionX !== -1) {
							_game.level.platforms.x.splice(removedPlatformPositionX, 1);
						}

						if (_game.level.platforms.references.length > _game.level.platforms.maxCount) {
							_game.level.platforms.currentGroupTempId = _game.level.platforms.references[0].platformGroupId;
						}
					} while (_game.level.platforms.groups.indexOf(_game.level.platforms.currentGroupTempId) !== -1);
				}
			},
			checkForNewBlocks: function() {
				var farestPlatformDistance = _game.level.platforms.x.length === 0 ? 0 : _game.level.getFarestPlatformDistance();

				if (farestPlatformDistance > _game.level.platforms.minPlayerDistance) {
					_game.level.platforms.newPlatformPosition = {
						x: _game.level.getHorizontalVariation(true),
						y: _game.level.getHorizontalVariation(),
						z: 0
					};

					_game.level.addBlock([
							_game.level.platforms.lastPlatformPosition.x - _game.level.platforms.newPlatformPosition.x,
							_game.level.platforms.lastPlatformPosition.y + _game.level.platforms.newPlatformPosition.y,
							_game.level.platforms.lastPlatformPosition.z + _game.level.platforms.newPlatformPosition.z
					]);
				}
			},
			getFarestPlatformDistance: function() {
				return -(Math.round(Math.abs(Math.min.apply(Math, _game.level.platforms.x)) + (Math.abs(_game.player.mesh.position.x) * (_game.player.mesh.position.x >= 0 ? 1 : -1))));
			},
			getLastPlatformSize: function() {
				return [_game.level.platforms.lastPlatformSize.x,
						_game.level.platforms.lastPlatformSize.y,
						_game.level.platforms.lastPlatformSize.z];
			},
			getLastPlatformPosition: function(offsetX, offsetY, offsetZ) {
				return [_game.level.platforms.lastPlatformPosition.x + (offsetX || 0), _game.level.platforms.lastPlatformPosition.y + (offsetY || 0), _game.level.platforms.lastPlatformPosition.z + (offsetZ || 0)];
			},
			getMaxPlatformToPlayerDistance: function(axis, additionalOffset) {
				return (_game.level.getLastPlatformSize()[axis] / 2) + _game.level.newPlatformSize[axis] + _game.level.platforms.maxPlatformToPlayerDistance + (additionalOffset || 0);
			},
			getHorizontalVariation: function(onlyPlus, overrideMaximum) {
				return (onlyPlus ? 1 : window.game.helpers.plusMinus()) * window.game.helpers.random(_game.level.platforms.minVariationHorizontal, overrideMaximum || _game.level.platforms.maxVariationHorizontal);
			},
			increaseFogDepth: function () {
				if (!_game.level.isIncreasedFog) {
					window.clearTimeout(_game.level.fogIncreaseTimeout);

					_game.level.fogIncreaseTimeout = window.setInterval(function () {
						_three.fogDepth += 0.00001;
						_three.scene.fog = new THREE.FogExp2(window.game.static.colors.darkGreen, _three.fogDepth);

						if (_three.fogDepth >= _three.fogDepthMaximum) {
							window.clearTimeout(_game.level.fogIncreaseTimeout);
							_three.scene.fog = new THREE.FogExp2(window.game.static.colors.darkGreen, _three.fogDepthMaximum);
						}
					}, 100);
				}
			},
			toggleSlowMotion: function() {
				if (!_game.player.isSlowMotion) {
					_game.player.speed = !_cannon.isSlowMotion ? _game.player.speedSlowMotion : _game.player.speedDefault;
					_game.player.speedMax = !_cannon.isSlowMotion ? _game.player.speedMaxSlowMotion : _game.player.speedMaxDefault;
					_game.player.rotationSpeed = !_cannon.isSlowMotion ? _game.player.rotationSpeedSlowMotion : _game.player.rotationSpeedDefault;
					_game.player.rotationSpeedMax = !_cannon.isSlowMotion ? _game.player.rotationSpeedMaxSlowMotion : _game.player.rotationSpeedMaxDefault;

					_cannon.timestep = _cannon.isSlowMotion ? _cannon.timestepDefault : _cannon.timestepSlowMotion;
					_cannon.isSlowMotion = !_cannon.isSlowMotion;

					_ui.toggleElement("slowmotion", true);

					_game.level.slowMotionTimeout = setTimeout(function () {
						_ui.toggleElement("slowmotion", false);

						window.clearInterval(_game.level.slowMotionFlickerInterval);
						window.clearTimeout(_game.level.slowMotionFlickerActivationTimeout);

						_game.player.speed = _game.player.speedDefault;
						_game.player.speedMax = _game.player.speedMaxDefault;
						_game.player.rotationSpeed = _game.player.rotationSpeedDefault;
						_game.player.rotationSpeedMax = _game.player.rotationSpeedMaxDefault;
						_cannon.timestep = _cannon.timestepDefault;
						_cannon.isSlowMotion = false;

						_game.player.isSlowMotion = false;
					}, _game.level.slowMotionTime);

					_game.level.slowMotionFlickerActivationTimeout = setTimeout(function () {
						_game.level.slowMotionFlickerInterval = window.setInterval(function () {
							if (!_ui.getElementAttribute("slowmotion", "data-visible") || _ui.getElementAttribute("slowmotion", "data-visible") === "false") {
								_ui.setElementAttribute("slowmotion", "data-visible", "true");
								_ui.toggleElement("slowmotion", true);
							} else {
								_ui.setElementAttribute("slowmotion", "data-visible", "false");
								_ui.toggleElement("slowmotion", false);
							}
						}, 200);
					}, _game.level.slowMotionFlickerAfterTime);
				}
			}
		},
		highestScore: 0,
		audio: {
			// Attributes
			music: null,
			platform: null,
			slowmotion: null,

			// Methods
			init: function () {
				_game.audio.music = document.querySelector("#game-audio-music");

				_game.audio.music.play();

				_game.audio.music.addEventListener("ended", function () {
					_game.audio.music.play();
				});

				_game.audio.platform = document.querySelector("#game-audio-platform");
				_game.audio.slowmotion = document.querySelector("#game-audio-slowmotion");
			}
		},

		// Methods
		init: function(options) {
			_game.setupComponents(options);
			_game.setupUi();

			_game.audio.init();

			_game.player.create();
			_game.level.create();

			_game.loop();
		},
		destroy: function() {
			window.clearTimeout(_game.level.fogIncreaseTimeout);
			window.clearTimeout(_game.level.slowMotionFlickerActivationTimeout);
			window.clearTimeout(_game.level.slowMotionTimeout);
			window.clearTimeout(_game.level.airboostResetProgressTimeout);
			window.clearInterval(_game.level.slowMotionFlickerInterval);
			window.clearInterval(_game.level.airboostFlickerInterval);
			window.cancelAnimationFrame(_three.animationFrameLoop);

			_cannon.destroy();
			_cannon.setup();
			_three.destroy();
			_three.setup();
			_ui.destroy();

			_ui.updateAirboostUi();

			_ui.showGameoverInfobox();

			_game.player = window.game.helpers.cloneObject(_gameDefaults.player);
			_game.level = window.game.helpers.cloneObject(_gameDefaults.level);

			_game.player.create();
			_game.level.create();

			_game.loop();
		},
		loop: function() {
			_three.animationFrameLoop = window.requestAnimationFrame(_game.loop);

			_cannon.updatePhysics();
			_game.player.update();

			_three.render();
		},
		setupComponents: function (options) {
			_ui = window.game.ui();
			_events = window.game.events();
			_three = window.game.three();
			_cannon = window.game.cannon();

			_three.init(options);

			_cannon.init(_three);

			_events.init(_three);
			_events.onKeyDown = function () {
				if (_events.keyboard.pressed[_game.player.controlKeys.inAirBoost]) {
					_game.player.airboost();
				}

				if (!_ui.hasClass("infoboxKeyboard", "no-height") && !_ui.hasClass("infoboxKeyboard", "hidden") && !_ui.hasClass("infoboxKeyboard", "fade-out") && !_ui.hasClass("infoboxKeyboard", "fade-out-slow")) {
					_ui.addClass("infoboxKeyboard", "fade-out-slow");
				}

				if (!_ui.hasClass("infoboxGameover", "no-height") && !_ui.hasClass("infoboxGameover", "hidden") && !_ui.hasClass("infoboxGameover", "fade-out") && !_ui.hasClass("infoboxGameover", "fade-out-slow") && !_ui.hasClass("infoboxGameover", "newgame-blocker")) {
					_ui.addClass("infoboxGameover", "fade-out-slow");
				}
			};
		},
		setupUi: function () {
			_ui.init();

			_ui.updateUi = function() {
				var playerHeight = Math.round(_game.player.mesh.position.z - 2);

				_game.level.score = Math.max(_game.level.score, playerHeight);

				if (_game.level.score > 50) {
					_ui.setElementValue("height", _game.level.score);
				} else {
					_game.level.score = 0;
				}
			};

			_ui.updateAirboostUi = function() {
				_ui.setElementAttribute("airboostsProgress", "data-visible", "true");
				_ui.toggleElement("airboostsProgress", true);

				window.clearInterval(_game.level.airboostFlickerInterval);
				window.clearTimeout(_game.level.airboostResetProgressTimeout);
			};

			_ui.elements.btnToggleSound.addEventListener("click", function (event) {
				if (_ui.elements.btnToggleSound.className === "sound-off") {
					_ui.elements.btnToggleSound.className = "sound-on";
					_game.audio.music.volume = 1;
					_game.audio.platform.volume = 1;
					_game.audio.slowmotion.volume = 1;
				} else {
					_ui.elements.btnToggleSound.className = "sound-off";
					_game.audio.music.volume = 0;
					_game.audio.platform.volume = 0;
					_game.audio.slowmotion.volume = 0;
				}

				event.preventDefault();
			});

			_ui.showGameoverInfobox = function() {
				if (_game.level.score >= _game.highestScore) {
					_game.highestScore = _game.level.score;
				}

				_ui.setElementValue("gameoverScore", _game.level.score);
				_ui.setElementValue("gameoverHighestScore",  Math.max(_game.level.score, _game.highestScore));

				_ui.removeClass("infoboxGameover", "hidden");
				_ui.removeClass("infoboxGameover", "fade-out-slow");
				_ui.removeClass("infoboxGameover", "fade-out");

				_ui.addClass("infoboxGameover", "newgame-blocker");

				setTimeout(function () {
					_ui.removeClass("infoboxGameover", "newgame-blocker");
				}, 2000);
			};
		}
	};

	var _ui;
	var _events;
	var _three;
	var _cannon;
	var _gameDefaults = {
		player: window.game.helpers.cloneObject(_game.player),
		level: window.game.helpers.cloneObject(_game.level)
	};

	return _game;
};